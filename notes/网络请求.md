##### Http、TCP、UDP

TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。
网络层有IP协议，传输层中有TCP协议与UDP协议，应用层有FTP、HTTP DNS
socket只是一种连接模式，面向的两种协议，基于流的TCP，基于用户数据包的UDP


### square/okhttp.git: Socket连接

https://github.com/square/okhttp/wiki/Calls 首先明确概念

https://github.com/square/okhttp/blob/c358656c8799d30fd422448153e99a5dd37e298a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java

1 executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,

          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));

2 RealConnection/AndroidPlatform # Platform.get().connectSocket(

3 RealCall :自定义的拦截器（可以header,log,https），重试拦截器，缓存拦截器，连接拦截器。。

  Response getResponseWithInterceptorChain() throws IOException {
    // Build a full stack of interceptors.
    List<Interceptor> interceptors = new ArrayList<>();
    interceptors.addAll(client.interceptors());／／用户可定义的
    interceptors.add(retryAndFollowUpInterceptor);//重试
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    interceptors.add(new CacheInterceptor(client.internalCache()));
    interceptors.add(new ConnectInterceptor(client));
    if (!forWebSocket) {
      interceptors.addAll(client.networkInterceptors());//重定向之类
    }
    interceptors.add(new CallServerInterceptor(forWebSocket));//the last interceptor真正的网络请求
    Interceptor.Chain chain = new RealInterceptorChain(
        interceptors, null, null, null, 0, originalRequest);
    return chain.proceed(originalRequest);
  }
4 CallServerInterceptor
httpCodec.createRequestBody(request, request.body().contentLength())

httpCodec.openResponseBody(response)

5 责任链模式

 https://zh.wikipedia.org/wiki/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F 

https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/chain-of-responsibility/AigeStudio ViewGroup事件传递

每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。

这里有个crush：interface Interceptor {

    if (response == null) {
      throw new NullPointerException("interceptor " + interceptor + " returned null");
    }
解决：你自定义的Interceptor，要把异常抛出来 intercept(Chain chain) throws IOException
6 http://www.jianshu.com/p/7b29b89cd7b5 

7 OKio

8 https://publicobject.com/2016/07/03/the-last-httpurlconnection/ 作者之一 比较HttpURLConnection

9 应用

http://www.tuicool.com/articles/3eiM3aI  利用 OkHttp Interceptor 模拟数据

10 封装库


## square/retrofit.git

https://github.com/square/retrofit/wiki/Retrofit-Tutorials 

0 概念 Retrofit is pluggable  

动态代理
```
public <T> T create(final Class<T> service) {
    Utils.validateServiceInterface(service);
    if (validateEagerly) {
      eagerlyValidateMethods(service);
    }
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
        new InvocationHandler() {
          private final Platform platform = Platform.get();
          @Override public Object invoke(Object proxy, Method method, Object[] args)
              throws Throwable {
            // If the method is a method from Object then defer to normal invocation.
            if (method.getDeclaringClass() == Object.class) {
              return method.invoke(this, args);
            }
            if (platform.isDefaultMethod(method)) {
              return platform.invokeDefaultMethod(method, service, proxy, args);
            }
            ServiceMethod<Object, Object> serviceMethod =
                (ServiceMethod<Object, Object>) loadServiceMethod(method);
            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);
            return serviceMethod.callAdapter.adapt(okHttpCall);
          }
        });
  }
```
ServiceMethod封装了：
* Call Adapters ： com.squareup.retrofit2:adapter-rxjava2，以RxJavaCallAdapter为例，把一个Call转换为Observable。Observable<?> observable = Observable.create(func);
* Converters：com.squareup.retrofit2:converter-gson
* 用Call包装了Request，实现类OkHttpCall
* 你定义的service interface中的方法，注解／返回类型／参数

1 Response结果能在UI线程直接使用吗？

```
  Response<T> parseResponse(okhttp3.Response rawResponse) throws IOException {
    ResponseBody rawBody = rawResponse.body();
    // Remove the body's source (the only stateful object) so we can pass the response along.
    rawResponse = rawResponse.newBuilder()
        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
        .build();
    int code = rawResponse.code();

    if (code < 200 || code >= 300) {／／错误码
      try {
        // Buffer the entire body to avoid future I/O.
        ResponseBody bufferedBody = Utils.buffer(rawBody);
        return Response.error(bufferedBody, rawResponse);
      } finally {
        rawBody.close();
      }
    }
    if (code == 204 || code == 205) {／／成功，但没有响应体
      rawBody.close();
      return Response.success(null, rawResponse);
    }
    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
    try {
      T body = serviceMethod.toResponse(catchingBody);
      return Response.success(body, rawResponse);／／成功，有响应体
    } catch (RuntimeException e) {
      // If the underlying source threw an exception, propagate that rather than indicating it was
      // a runtime exception.
      catchingBody.throwIfCaught();
      throw e;
    }
  }
```

跟RxJavaCallAdapterFactory并列的默认加入的ExecutorCallAdapterFactory，它的callbackExecutor是MainThreadExecutor，也就是一个handler，用来把响应结果回调给UI线程。


2 来看Retrofit.Builder中的参数：

okhttp3.Call.Factory callFactory：真正处理请求的对象，默认是okhttp3。

HttpUrl baseUrl：请求的根地址。

List<Converter.Factory> converterFactories：解析器，负责解析请求的注解和应答的数据源。

List<CallAdapter.Factory> adapterFactories：执行请求的单元，默认是ExecutorCallAdapterFactory。

Executor callbackExecutor：操作请求的单元，默认是MainThreadExecutor。

boolean validateEagerly：是否提前执行方法参数注解的解析。


3 使用方式

Retrofit.create(final Class<T>service);//

        每个类都是Class的范性

        service必须是接口，不能有继承

@GET("/api/4/news/latest")

    Observable<Object> getLastestNews(Callback callback);//错误写法

   返回void +无Callback参//也是错误写法

Must have return type or Callback as last argument。//要么要么

正确： 

  返回void ＋ 最后一个参数为Callback+ 必须指定泛型

  返回非void ＋ 没有Callback参数

这两种写法都是异步的，会启动一个叫Retrofit-Idle的线程(它底层用了OkhttpThreadPool)，

4 动态代理  

https://mp.weixin.qq.com/s?__biz=MzIxOTI1NTk5Nw==&mid=2650047517&idx=1&sn=85d88950bfda21106c58be536cdfc9cc&chksm=8fde21cfb8a9a8d946c1276f4c6e5374b167eb11168428333213c4164264d840bd38473f9d02&scene=21#wechat_redirect 
因为Proxy.newProxyInstance()的第二个参数，所以你知道为什么service必须是接口。
可以干很多事：无痛埋点。。

======

Volley    生产者消费者

NetworkDispatcher/ExecutorDelivery





Volley 源码解析

http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90

http://blog.csdn.net/column/details/yuan-android-net.html

https://android.googlesource.com/platform/frameworks/volley/

https://github.com/mcxiaoke/android-volley

http://www.jianshu.com/p/9e17727f31a1 

1 整个流程

Volley中的线程交互

你知道或者被告知，request是新线程异步的，onResponse是UI线程的，但是为什么呢？来扒一扒。

涉及到Volley中的这几个实现类：

Volley	入口类

RequestQueue	

NetworkDispatcher extends Thread

ExecutorDelivery implements ResponseDelivery

然后一个Request实现，比如StringRequest

00 

 newRequestQueue();

 queue.add(request);		//使用者往队列加

Volley

01  queue.start();

RequestQueue

02  

记录一个UI线程的Handler

    public RequestQueue(Cache cache, Network network, int threadPoolSize) {

        this(cache, network, threadPoolSize,

                new ExecutorDelivery(new Handler(Looper.getMainLooper())));

    }

4个NetworkDispatcher,启了4个线程，不停的轮训请求队列

for (int i = 0; i < mDispatchers.length; i++) {

            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,

                    mCache, mDelivery);

            mDispatchers[i] = networkDispatcher;

            networkDispatcher.start();

        }

NetworkDispatcher extends Thread

03  不断从队列里取request，执行，分发

while (true) {

 request = mQueue.take();			//从队列取

 NetworkResponse networkResponse = mNetwork.performRequest(request);

 mDelivery.postResponse(request, response);

}

ExecutorDelivery implements ResponseDelivery

04  通过那个handler把response传递给UI线程

mResponsePoster = new Executor() {

            @Override

            public void execute(Runnable command) {

                handler.post(command);

            }

        };

mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));

mRequest.deliverResponse(mResponse.result);

然后一个Request实现，比如StringRequest

05

@Override

    protected void deliverResponse(String response) {

        mListener.onResponse(response);

    }

Volley.newRequestQueue(SportsApp.getContext());发生了什么？

尼玛，线程池＋while(true)。好意思问！

你为什么敢在onResponse(BaseParser response)里更新UI？

尼玛，万恶的handler，万恶的looper

2 Volley与HttpUrlConnection什么关系？

Volley.java

new newRequestQueue()的时候

if (Build.VERSION.SDK_INT >= 9) {

                stack = new HurlStack();

            } else {

                // Prior to Gingerbread, HttpUrlConnection was unreliable.

                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html

                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));

            }

3 出错重试机制  DefaultRetryPolicy

基于连接时间的

int timeoutMs = request.getTimeoutMs();

        connection.setConnectTimeout(timeoutMs);

        connection.setReadTimeout(timeoutMs);

4 缓存机制 CacheDispatcher

final Request<?> request = mCacheQueue.take();//把之前的请求存了

6 异常机制

VolleyError

https://github.com/mcxiaoke/android-volley/blob/master/src/main/java/com/android/volley/VolleyError.java

https://github.com/mcxiaoke/android-volley/blob/master/src/main/java/com/android/volley/NetworkError.java

7  请求优先机制

AtomicInteger mSequenceGenerator = new AtomicInteger();

request.setSequence(getSequenceNumber());

Request<T> implements Comparable<Request<T>>

先比较enum Priority

相同再比较Sequence

8 debugging / log

mEventLog.add(tag, Thread.currentThread().getId());

9 用到的结构

PriorityBlockingQueue<Request<?>> mCacheQueue

PriorityBlockingQueue<Request<?>> mNetworkQueue//使用者add进来的request

5

Volleye的线程机制是 ： 4个线程，不停的轮训请求队列

AsyncTask    内部是:3.0前是一个ThreadPoolExecutor，线程数跟CPU有关。3.0后是一个worker线程

ThreadPoolExcutor

java.util.concurrent的概念

Runnable   一个可执行单元

Executor 	可执行单元的执行器

https://github.com/mcxiaoke/android-volley/blob/master/src/main/java/com/android/volley/ExecutorDelivery.java



