### 面试题：产生一个长度为100的数组，为数组中的每一项随机填充1-100之间的数并且保证不重复 
换句话说：一个数组存放了1-100的数，求一种算法使数组乱序。
换句话说：一副扑克牌54张牌，洗牌。
 
借助Map查重：越到后面，重复率越高，while一直转。

```
public int[] getResultArr(){
    int[] resultArr = new int[100];
    Map<int,int> tempMap = new HashMap(128);
    Random random = new Random();

    for(int i=0;i<resultArr.length;i++){

        int key = random.next(1,101);// 1- 100
        while(tempMap.contains(key)){
            key = random.next(1,101);
        }
        resultArr[i] = key;
        tempMap.put(key,1);
    }
    return resultArr;
}
```

滚动数组：
```
public int[] getResultArr2(){
    int[] arr = new int[100];
    int[] temp = new int[100];

    // 1 - 100
    for(int i=0;i<temp.length;i++){
        temp[i] = i+1;
    }

    //从temp的 [0,max]是有用的备选数
    int max = arr.length;
    Random random = new Random();
    for(int i=0;i<arr.length;i++){
        int index = random.next(0,max);
        arr[i] = temp[index];
        temp[index] = temp[max - 1];  
        max--;
    }
    return arr;
}
```

Fisher-Yates算法:
https://ashan.org/archives/925
```
public int[] getRandomArr3(){
    int[] arr = new int[100];

    for(int i=0;i<arr.length;i++){
        arr[i] = i+1;
    }

    Random random = new Random();
    int temp = 0;
    for(int i=arr.length-1;i>-1;i--){
        int key = random.next(100);
        temp = arr[key];
        arr[i] = temp;
        arr[key] = arr[i];
    }

    return arr;
}
```