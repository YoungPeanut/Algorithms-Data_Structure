
http://blog.csdn.net/mimi9919/article/details/51335337
找出一个数组中的两个数字，让这两个数字之和等于一个给定的值.
Example:
 Given nums = [2, 7, 11, 15], target = 9,
 Because nums[0] + nums[1] = 2 + 7 = 9,
 return [0, 1].

 1.直接穷举，O(n^2)

 2.
 排序，二分查找 sum-arr[i]  ，
 快排O(n*logn)+ 二分O(logn) * 遍历，最后O(n*logn)。
 然后更快的查找方式:hash表，那就不需要快排了，但需要hash表存储空间
 ```
 public int[] getSumNus(int[] arr,int sum){
     int[] result = new int[2];
     Map<int,int> map = new HashMap(arr.length);
     for(int i=0;i<arr.length;i++){
         if(arr[i] + map.get(arr[i]) == sum){
             result[0] = arr[i];
             result[1] = map.get(arr[i]);
         }
         map.put(arr[i],sum - arr[i]);
     }
     return result;
 }

 ```
 3.利用快排partition的左右指针  
 首先对数组进行排序，时间复杂度为（N*log2N）。
      然后令i = 0，j = n-1，看arr[i] + arr[j] 是否等于Sum，如果是，则结束。如果小于Sum，则i = i + 1；如果大于Sum，则 j = j – 1。这样只需要在排好序的数组上遍历一次，就可以得到最后的结果，时间复杂度为O（N）。两步加起来总的时间复杂度O（N*log2N）

```
//先排序 然后
 public int[] getSumNus(int[] arr,int sum){
     int[] result = new int[2];
     int i,j;
     for(i=0,j=arr.length-1;i<j){
         if(arr[i]+arr[j] > sum){
             j--;
         } else if(arr[i]+arr[j] < sum){
             i++;             
         } else{
             result[0] = arr[i];
             result[1] = arr[j];
            return result;
         }
     }
     return result;
 }
```

4.扩展
找三个数的和：排序，遍历arr[i]时，调用上面的函数getSumNum(arr , Sum-arr[i])即可。

find3(){
    for(arr){
        find2(sum-arr[i])
        if(find2){

        }
    }
}

find4(){
    for(arr){
        find3(sum-arr[i])
        if(find3){
            append
        }
    }
}

找任意m个数的和：递归+上面
```
 public List getSumN(int[] arr,int sum,int n){
     List<Integer> result = new ArrayList();
     if(n == 2){
         return getSumNus(arr,sum);
     }
     for(i=0,i<arr.length-1;i++){
        result.addAll(getSumN(arr,sum-arr[i],n--));
     }
     return result;
 }

```

