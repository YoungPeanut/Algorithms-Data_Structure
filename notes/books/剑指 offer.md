## 第一章 面试流程

## 第二章 面试需要的基础知识

### 面试题2 实现单例 Singleton
1 Double Check
2 静态内部类持有外部类单例
3 Java中枚举类的单例

### 面试题3 一个二维数组a[m][n]，行元素左右递增，列元素上下递增，现给定一个整数k，查找是否包含。
数组，连续内存顺序存储，查找快增删慢空间利用率低。
解：如果正常思维从a[0][0]开始比较，k大的话还需要继续向右向下找，只排除了一个元素。那如果从数组右上角元素开始比较,k大的话能排除一行，k小的话能排除一列。右上角元素的特殊性在于，左边都比它小，下边都比它大，左下角也有类似特殊性。

```
        int[][] arr = new int[][]{
            {1,2,3,4,5,6},
            {7,8,9,10,11,12},
            {13,14,15,16,17,18},
            {19,20,21,22,23,24},
            {25,26,27,28,29,30},
        };
        boolean isfind = findK_while(arr,5,6,10);
    // for 与 while的区别
    boolean findK_while(int[][] arr,int m,int n,int k) {
        int i = 0;
        int j = n-1;
        while (i < m && j >= 0){
            if (k > arr[i][j]){
                i++;
            } else if (k < arr[i][j]){
                j--;
            } else {
                return true;
            }
        }
        return false;
    }
    // for循环无法直接实现，除非借助两个List记录排除的行列
    boolean findK_for(int[][] arr,int m,int n,int k) {

        for (int i = 0; i <= m - 1; i++) { //第一个比较a[0][n-1]
            for (int j = n - 1; j >= 0; j--) {
                if (k > arr[i][j]) {
                    i++;                //把第i行排除，但j列无法排除
                    j++;                //排除后进入下一次j循环，执行了j--，这不对，+1补偿回来
                } else if (k < arr[i][j]) {
                    j--;                // 排除j列，无法排除i行
                    i--;                //这里如果做补偿，下次i循环就又回到上一步了，等于上面排除i行白做了
                } else {
                    return true;
                }
            }
        }
        return false;
    }
```

### 面试题4 把空格替换为%20，输入We are happy，输出We%20are%20happy
字符串,其实就是数组，所以要按数组的结构来思考。
url中特殊字符转换规则：% + ASCII码的十六进制。空格是32，#是35。
解：
1 O(n²) 只在原字符串上做操作，遇到空格，替换的时候需要先把后面的字符后移两位。
2 O(n) 开辟一个新的足够的空间数组，遍历字符串，元素复制到新数组，见空格则替换。

### 面试题5 从尾到头打印单链表
链表，动态添加节点，没有闲置内存。查找慢增删快空间利用率高。
解：
1 从头节点遍历链表，进栈，出栈打印。
2 递归本质是个栈结构。递归，打印。递归有栈溢出风险。

### 面试题6
树，