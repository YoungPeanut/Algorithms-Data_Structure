
换肤 ： LayoutInflaterCompat.setFactory(layoutInflater, new SkinFactory(this));
https://github.com/yewei02538/TodayNews  仿今日头条

## 实践
https://github.com/fashare2015/Dynamic-Load-Learning 

## 类加载机制
https://www.tuicool.com/articles/yquQvqM 
1 负责加载类的类就是类加载器，将字节码文件加载到内存，创建Class对象。它的输入是完全限定的类名，输出是Class对象。
2 双亲委派" 模型，子ClassLoader有一个变量parent指向父ClassLoader，在子ClassLoader加载类时，一般会首先通过父ClassLoader加载。为什么要先让父ClassLoader去加载呢？这样，可以避免Java类库被覆盖的问题，比如用户程序也定义了一个类java.lang.String，通过双亲委派，java.lang.String只会被Bootstrap ClassLoader加载，避免自定义的String覆盖Java类库的定义。
3 ClassLoader的loadClass方法与Class的forName方法都可以加载类，但前者不会执行类的初始化代码。

1 Android中有两个ClassLoader分别为 dalvik.system.DexClassLoader 和 dalvik.system.PathClassLoader。
2 PathClassLoader 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk（因为安装过的 apk 在 cache 【 /data/dalvik-cache】中存在缓存的 dex 文件）。
换肤 https://github.com/cxmscb/android-skinchanged-By-PathClassLoader/ ，会发现皮肤插件有个安装过程。

3 DexClassLoader 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。

http://pingguohe.net/2017/12/25/android-plugin-practice-part-2.html

## 热修复
http://pingguohe.net/2018/01/11/android-plugin-practice-part-3.html

## APK的安装过程
https://blog.csdn.net/bupt073114/article/details/42298337

/data/app：安装时，把APK拷贝于此。
/data/data：安装完成后，在/data/data目录下自动生成和应用包名一样的文件夹，用于存放应用程序的数据。
/data/dalvik-cache：存放APK的odex文件，便于应用启动时直接执行。

## Activity的启动过程

http://pingguohe.net/2017/12/25/android-plugin-practice-part-1.html


https://www.jianshu.com/p/c6b04b3f911d
ActivityThread的performLaunchActivity方法

```
// Instrumentation
public Activity newActivity(ClassLoader cl, String className,
            Intent intent)
            throws InstantiationException, IllegalAccessException,
            ClassNotFoundException {
        return (Activity)cl.loadClass(className).newInstance();
    }

// ActivityThread
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        Activity activity = null;
        try {
//这里调用Instrumentation的newActivity来创建一个新的Activity
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
        } catch (Exception e) {
        }

        try {
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);

                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);

                if (customIntent != null) {
                    activity.mIntent = customIntent;
                }
                r.lastNonConfigurationInstances = null;
                activity.mStartedActivity = false;
                int theme = r.activityInfo.getThemeResource();
                if (theme != 0) {
                    activity.setTheme(theme);
                }

                activity.mCalled = false;
                if (r.isPersistable()) {
//这个方法里面会调用目标Activity的onCreate方法
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
                if (!activity.mCalled) {
                    throw new SuperNotCalledException(
                        "Activity " + r.intent.getComponent().toShortString() +
                        " did not call through to super.onCreate()");
                }
                r.activity = activity;
                r.stopped = true;
.......
        } catch (SuperNotCalledException e) {
            throw e;

        } catch (Exception e) {
......
        }

        return activity;
    }

```

## 65535

当Android系统安装一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。 但是在早期的Android系统中，DexOpt有一个问题，DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对低版本的Android系统做兼容。 为了解决方法数超限的问题，需要将该dex文件拆成两个或多个，为此谷歌官方推出了multidex兼容包

## 360 DroidPlugin 

https://github.com/Qihoo360/DroidPlugin 

http://www.infoq.com/cn/presentations/the-realization-principle-and-application-of-droidplugin
http://www.infoq.com/cn/news/2015/09/droidplugin-zhangyong-interview
源码阅读整体思路：Demo功能入手，直达源码。

0 PluginApplication

0-0  宿主App启动，hook并模拟android framework 运行环境，宿主App就是framework，插件就是上面对app

PluginHelper.getInstance().applicationOnCreate(getBaseContext());

```

try {
   PluginPatchManager.getInstance().init(baseContext);
   PluginProcessManager.installHook(baseContext);
} catch (Throwable e) {
   Log.e(TAG, "installHook has error", e);
}

try {
   if (PluginProcessManager.isPluginProcess(baseContext)) {
       PluginProcessManager.setHookEnable(true);
   } else {
       PluginProcessManager.setHookEnable(false);
   }
} catch (Throwable e) {
   Log.e(TAG, "setHookEnable has error", e);
}

try {
   PluginManager.getInstance().addServiceConnection(PluginHelper.this);
   PluginManager.getInstance().init(baseContext);
} catch (Throwable e) {
   Log.e(TAG, "installHook has error", e);
}

```

初始化了 PluginPatchManager ：插件管理类，检查插件的activity是否可以启动；

1 ApkFragment

1-0 apk插件安装过程

PluginManager.getInstance().installPackage(item.apkfile, 0);


https://github.com/zzz40500/Tinker_imitator  热修复 需要重启
0 
multiDexEnabled true
App extends MultiDexApplication （android.support.multidex.MultiDexApplication）

1 把旧的patch文件从当前应用的apk文件里导出来

   String sourceApkPath = getSourceApkPath(mApplication, mApplication.getPackageName());
   JarFile jarFile = new JarFile(sourceApkPath);
   Enumeration<JarEntry> entries = jarFile.entries();
   ZipEntry entry = jarFile.getEntry(className);
   if (entry != null) {
       InputStream inputStream = jarFile.getInputStream(entry);
       OutputStream out = new FileOutputStream(new File(sDexPath, entry.getName()));
       IOUtils.copy(inputStream, out);
   }

2 新旧patch比较并安装
int bspatch = Bsdiff.bspatch(oldDex.getPath(), newDex.getPath(), file.getPath());
so文件，看不到。。。

https://github.com/fengjundev/Android-Skin-Loader 换肤 ，不用重启

1 SkinManager.getInstance().load(skin.getAbsolutePath(),callback)    加载皮肤资源都干了什么
／／把新皮肤路径加到AssetManager ，hook的方式 ，就是Runtime嘛，不用重启 
Method addAssetPath = assetManager.getClass().getMethod("addAssetPath", String.class);
addAssetPath.invoke(assetManager, skinPkgPath);
／／把hook完的assetManager构造成Resources
Resources superRes = context.getResources();
Resources skinResource = new Resources(assetManager,superRes.getDisplayMetrics(),superRes.getConfiguration());
总之得到了新皮肤的Resources

2  然后你要继承我的BaseActivity／BaseFragment才能用新Resources
看BaseActivity里干了啥：
getLayoutInflater().setFactory(mSkinInflaterFactory);／／我来定义LayoutInflater的解析
SkinInflaterFactory implements Factory
parseSkinAttr(context, attrs, view);
skinItem.apply();
比如BackgroundAttr＃apply()，就来到了SkinManager.getInstance().getDrawable(attrValueRefId);
SkinManager的getDrawable／getColor明显是要用新Resources，
这样就换肤了。
比如你的布局文件里android:background="@color/color_app_bg"，就会找到新皮肤里的color_app_bg

3 皮肤包是什么？如何生成？
把皮肤包工程直接编译生成apk文件，更改后缀名为.skinj即可（防止用户点击安装）

final def TARGET_SKIN_DIR = '../skin-package/'
def skinName = "BlackFantacy.skin"
assembleRelease.doLast {
    println("=====================assembleRelease.doLast.begin.=========================")

    def dir = new File(TARGET_SKIN_DIR)
    if (!dir.exists()) {
        dir.mkdirs()
    }

    def f = new File(TARGET_SKIN_DIR + skinName)
    if (f.exists()) {
        f.delete()
    }

    copy {
        from('build/outputs/apk')
        into(TARGET_SKIN_DIR)
        include '*.apk'
        exclude '**/*-unaligned.apk'
        rename ('android-skin-loader-skin-release.apk', skinName)
    }

    println("=====================assembleRelease.doLast success.=========================")
}
配置gradle，直接在/skin-package/目录得到.skin
